/*
 * This code contains the code for 'Bank'
 * The Bank accept money order from the merchant and verifies the customers identity
 * If verification is successful, it deducts the amount from customer's account 
 */

package digitalcash;

import java.io.*;
import java.math.BigInteger;
import java.net.ServerSocket;
import java.net.Socket;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.interfaces.RSAKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.X509EncodedKeySpec;
import java.util.Random;

// TODO: Auto-generated Javadoc
/**
 * The Class BankFrame.
 */
public class BankFrame extends javax.swing.JFrame {

    /** The Constant serialVersionUID. */
	private static final long serialVersionUID = 1L;
	
	/** The file. */
	static File file = new File("account.txt");
	
	/** The filename. */
	static String filename = "custpk.txt";
	
	/** The accountmatrix. */
	static String [][] accountmatrix = new String [2][3];
	
	/** The customer_balance. */
	static double customer_balance ;
    
    /** The customer_account. */
    static int customer_account;
    
    /** The merchant_balance. */
    static double merchant_balance;
    
    /** The merchant_account. */
    static int merchant_account;  
    
    /** The customer_identity. */
    static String customer_identity;
    
    /** The Uniq_ iden_ used. */
    static String [] Uniq_Iden_Used;
    
    /** The n. */
    static int n = 100;    
    
    /** The r. */
    static BigInteger r;	
    
    /** The uniqueness. */
    static String[] uniqueness = new String[100]; 
    
    /** The Money order amount. */
    static double MoneyOrderAmount = 0;
    
    /** The unblind_amount. */
    static double unblind_amount = 0;
    
    /** The matching amounts. */
    static boolean matchingAmounts = true; 
    
    /** The matching uniqueness. */
    static boolean matchingUniqueness = false; 
    
    /** The Identity string. */
    static String [] IdentityString;
    
    /** The getfromcust. */
    static BigInteger[] getfromcust = new BigInteger [100];
    
    /** The unblind_uniqueness. */
    static String unblind_uniqueness = "";
    
    /** The L_iden. */
    static String [] L_iden = new String [n];
    
    /** The R_iden. */
    static String [] R_iden = new String [n];
    
    /** The pubmodulus. */
    static BigInteger pubmodulus;
	 
 	/** The publicexpon. */
 	static BigInteger publicexpon;
    
    /**
     * Instantiates a new bank frame.
     */
    public BankFrame() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jButton2 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        setTitle("Bank");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Status"));

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 294, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 115, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        jButton2.setText("Connect with Customer");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton3.setText("Connect with merchant");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("Status"));

        jTextArea2.setColumns(20);
        jTextArea2.setRows(5);
        jScrollPane2.setViewportView(jTextArea2);

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 294, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 115, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(100, 100, 100)
                        .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 211, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(91, 91, 91)
                        .addComponent(jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 217, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 37, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(32, 32, 32))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(23, 23, 23))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(18, 18, 18)
                .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * J button2 action performed.
     *
     * @param evt the evt
     */
    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) 
    {//GEN-FIRST:event_jButton2ActionPerformed
        filetomatrix();         
        ConnectionWithCustomer();
        matrixtofile();  
    }//GEN-LAST:event_jButton2ActionPerformed

    /**
     * J button3 action performed.
     *
     * @param evt the evt
     */
    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) 
    {//GEN-FIRST:event_jButton3ActionPerformed
       filetomatrix();                         
       ConnectionWithMerchant();
       matrixtofile(); 
    }//GEN-LAST:event_jButton3ActionPerformed

    /**
     * The main method.
     *
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(BankFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(BankFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(BankFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(BankFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new BankFrame().setVisible(true);
                 
            }
        });
    }

/**
 * Connection with customer.
 */
public static void ConnectionWithCustomer()
	 {		 
		 ObjectOutputStream out = null;
		 ObjectInputStream  in = null;
		 int randomIndex = 0;
		 
		 try
		 {			 
			 ServerSocket welcomeSocket = new ServerSocket(8888);
			 Socket connectionSocket = welcomeSocket.accept();
			 while(true)
			 {				 				 
				 System.out.println("Request received from Customer");
                 BankFrame.jTextArea1.append("Request received from Customer\n");
				 in = new ObjectInputStream(connectionSocket.getInputStream());				
				 getfromcust = (BigInteger[]) in.readObject();
				 System.out.println("Received money orders from Customer");
                 BankFrame.jTextArea1.append("Received money orders from Customer\n");
				 in = new ObjectInputStream(connectionSocket.getInputStream());
				 r = (BigInteger) in.readObject();
        	 
				 Random rnd = new Random(123);
				 randomIndex = rnd.nextInt(getfromcust.length - 2) + 2;
				 uniqueness [randomIndex] = "xxxxxxx";
				 int i=0;
        	 
				 for ( i = 0; i < getfromcust.length; i++ )
				 {                 
					 if (i != randomIndex)
					 {						    						      
						 FileInputStream keyfis = null;
						 keyfis = new FileInputStream(filename);
						 byte[] encKey = new byte[keyfis.available()];
						 keyfis.read(encKey);
						 X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(encKey);
						 KeyFactory keyFactory = KeyFactory.getInstance("RSA");
						 PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);
						 keyfis.close();
						 pubmodulus = ((RSAKey) pubKey).getModulus();
						 publicexpon = ((RSAPublicKey) pubKey).getPublicExponent();
						 
						 BigInteger b = getfromcust[i];
						 BigInteger s =  b.multiply(r.modPow(publicexpon.negate(), pubmodulus)).mod(pubmodulus);
						 String line = new String(s.toByteArray());
						 
						 String[] parts = line.split(":");
						 unblind_amount = Double.parseDouble(parts[0]);
						 unblind_uniqueness = parts[1];
						 
						 /*
						 for (int j=2;j<=n+1;j++)
						 {
							 String line3 = parts [j];
							 String[] parts2 = line3.split(",");
							 L_iden[j-2] = parts2[0];
							 R_iden[j-2] = parts2[1];									 
						 }
						 */
						 
						 /*
						 String L = L_iden[3];						 
						 String R = R_iden[3];
						 String M = "";
						 for (int j = 0; j < R.length() && j < L.length(); j++) 
						 {
		                        M += R.charAt(j) ^ L.charAt(j);
						 }
						 */
						 //int charCode = Integer.parseInt(M, 2);
						 //String str = new Character((char)charCode).toString();
						 //String S1 = new String(M.toByteArray());
						 
						 /*
						 String input = M;
						 String output = "";
						 for(int x= 0; x <= input.length() - 8; x+=8)
						 {
						     int k = Integer.parseInt(input.substring(x, x+8), 2);
						     output += (char) k;
						 } 
						 
						 if(!customer_identity.equals(M))
						 {
							 System.out.println("Customer identity cannot be verified");							 
							 welcomeSocket.close();  	
							 break;							
						 }
						 */
						 						 
						 if(i == 0)
						 {
							 if ( unblind_amount != 0 )                     
								 MoneyOrderAmount= unblind_amount;                                                            
							 if( unblind_uniqueness != null )                         
                                 uniqueness[i] = unblind_uniqueness;                            
						 }
						 else
						 {      								           
							 if( unblind_amount != MoneyOrderAmount)
							 {                            
								 matchingAmounts = false;
							 }
							 else
							 {																
								 for ( int j = 0; j < i; j++ )
                                 {
									 if ( uniqueness[j].compareTo(unblind_uniqueness) == 0 )
									 {
										 matchingUniqueness = true;																				                                                            
									 }                                                    
                                 }
								 uniqueness[i] = unblind_uniqueness; 
							 }
						 }
					 }					 
				 }
				         	          	 
				 if(!matchingAmounts)
				 {                  						
					 System.out.println("Amounts do not match. Money Order denied");
                     BankFrame.jTextArea1.append("Amounts do not match. Money Order denied\n");
					 welcomeSocket.close();  	
					 break;
				 }
				 if (matchingUniqueness)
				 {
					 System.out.println("Duplicate uniqueness strings. Money Order denied");
                     BankFrame.jTextArea1.append("Duplicate uniqueness strings. Money Order denied\n");
					 welcomeSocket.close();  	
					 break;
				 }		
				 if(i == getfromcust.length)
					 break;
			 }
            
			if (customer_balance < MoneyOrderAmount)
			{
				System.out.println("Customer account balance low. Cannot sign money order.");
                BankFrame.jTextArea1.append("Customer account balance low. Cannot sign money order.\n");
				welcomeSocket.close();  	
			}
			else
			{
				System.out.println("Money orders look good. Do you want to sign?");								
				customer_balance = customer_balance - MoneyOrderAmount;
				updateaccount(customer_account,customer_balance);
				System.out.println("$" + MoneyOrderAmount + " debited from Customer account");
                BankFrame.jTextArea1.append("$" + MoneyOrderAmount + " debited from Customer account\n");
								
				byte[] bs = blindsign(getfromcust[randomIndex]);				
     			
				out = new ObjectOutputStream(connectionSocket.getOutputStream());
				out.flush();
				out.writeObject(bs);
				out.flush();				
				System.out.println("Signed money order sent to Customer");
                BankFrame.jTextArea1.append("Signed money order sent to Customer\n");
				
				out = new ObjectOutputStream(connectionSocket.getOutputStream());
				out.flush();
				out.writeObject(getfromcust[randomIndex]);
				out.flush();	
							
				out.close();
				in.close();
				connectionSocket.close();
				welcomeSocket.close();  	
			}
		 }catch(Exception ex) 
		 {
			 System.out.println("ERROR: ");
			 ex.printStackTrace();
		 }     				     			     		        	            		     	                 		  
	 }
	 	
	/**
	 * Connection with merchant.
	 */
	public static void ConnectionWithMerchant()
	 {				
		 ObjectInputStream in = null;		 
		 try
		 {
			 ServerSocket welcomeSocket = new ServerSocket(8899);
			 Socket connectionSocket = welcomeSocket.accept();
			 
			 while(true)
			 {				 				 
				 System.out.println("Request received from Merchant");
                 BankFrame.jTextArea2.append("Request received from Merchant\n");
				 /*
				 in = new ObjectInputStream(connectionSocket.getInputStream());
				 IdentityString = (String[]) in.readObject();
				 */
				 
				 in = new ObjectInputStream(connectionSocket.getInputStream());
				 BigInteger MOfromMerchant = (BigInteger) in.readObject();
				 				 
				 String line = new String(MOfromMerchant.toByteArray());
				 
				 String[] parts = line.split(":");
				 unblind_amount = Double.parseDouble(parts[0]);
				 unblind_uniqueness = parts[1];
				 //Boolean UniqDuplicate = CheckforUniq (unblind_uniqueness);
				 Boolean found = false;
				 File file3 = new File("usedMO.txt");
				 BufferedReader reader = new BufferedReader(new FileReader(file3));
				 String temp_line;
				 while ((temp_line = reader.readLine()) != null) 
				 {
					 found = temp_line.contains(unblind_uniqueness);					 
				 }
				 reader.close();
				 
				 if (found)
				 {
					 System.out.println("MO denied. Somebody is cheating");
                     BankFrame.jTextArea2.append("Duplicate money order found\n Money order denied\n");
					 break;
				 }
				 else
				 {
					 merchant_balance = merchant_balance + unblind_amount;
					 updateaccount(merchant_account,merchant_balance);
					 System.out.println("Merchant account has been credited for $" +unblind_amount);
                     BankFrame.jTextArea2.append("Merchant account has been credited for $" + unblind_amount+"\n"); 
					 
					 FileWriter fw = new FileWriter("usedMO.txt", true);
					 BufferedWriter writer = new BufferedWriter(fw);					 
					 writer.write( "\n" + unblind_uniqueness );
					 writer.close();
				 }
				 
				 /*
				 if (UniqDuplicate)
				 {
					 Boolean found;
					 //check for duplicate identity 
					 File file3 = new File("usedMO.txt");
					 BufferedReader reader = new BufferedReader(new FileReader(file3));
					 String line;
					 while ((line = reader.readLine()) != null) 
					 {						 
						 found = line.contains(MercUniq);
						 if (found)
						 {
							 String line2 = String.valueOf(MOfromMerchant);
							 if (line.equals(line2))
							 {
								 System.out.println("Merchant is cheating. MO denied"); 							 							 							 
							 }
							 else
							 {
								 System.out.println("Customer is cheating. MO denied"); 							 								
								 String[] L_iden1 = MOfromMerchant.getLIden();
								 String[] R_iden1 = MOfromMerchant.getRIden();
								 String[] L_iden2 = null;
								 String[] R_iden2 = null;
								 
								 String[] parts = line.split("-");
								 for (int j=1;j<=n;j++)
								 {
									 String line3 = parts [j];
									 String[] parts2 = line3.split(",");
									 L_iden2[j-1] = parts2[0];
									 R_iden2[j-1] = parts2[1];									 
								 }
								 for(int j=0; j<n; j++)
								 {
									 if (L_iden1[j] != "" || R_iden2[j] != "")
									 {
										 String L = L_iden1[j];						 
										 String R = R_iden2[j];
										 String M = null;
										 for (int k = 0; k < R.length() && k < L.length(); k++) 
										 {
						                        M += R.charAt(j) ^ L.charAt(j);
										 } 
										 System.out.println("The cheating customer is" + M);
										 break;
									 }
									 else
									 {
										 if (L_iden2[j] != "" || R_iden1[j] != "")
										 {
											 String L = L_iden2[j];						 
											 String R = R_iden1[j];
											 String M = null;
											 for (int k = 0; k < R.length() && k < L.length(); k++) 
											 {
							                        M += R.charAt(j) ^ L.charAt(j);
											 } 
											 System.out.println("The cheating customer is" + M);
											 break;
										 }
									 }
								 }
							 }
						 }
					 }
				 }
				 else
				 {
					 merchant_balance = merchant_balance + MOfromMerchant.getAmount();
					 updateaccount(merchant_account,merchant_balance,"");
					 System.out.println("Merchant account has been credited for $" + MOfromMerchant.getAmount());
					 //save used MO to file					
					 
					 String line = MercUniq;					 	
					 String[] L_iden = MOfromMerchant.getLIden();
					 String[] R_iden = MOfromMerchant.getRIden();
					 
					 for (int j=0; j<n; j++)
					 {
						 line = line.concat ("-");
						 line = line.concat (L_iden[j]);
						 line = line.concat (",");
						 line = line.concat (R_iden[j]);						        
					 }
					 
					 FileWriter fw = new FileWriter("usedMO.txt");
					 BufferedWriter writer = new BufferedWriter(fw);					 
					 writer.write(line);					 
				 }
				 */
				 in.close();
				 connectionSocket.close();
				 welcomeSocket.close(); 
				 break;				  
			 }
		 }catch(Exception ex) 
		 {
			 System.out.println("ERROR: ");
			 ex.printStackTrace();
		 }  
	 }
	 
	 /**
 	 * Blindsign.
 	 *
 	 * @param getfromcust the getfromcust
 	 * @return the byte[]
 	 */
 	public static byte[] blindsign(BigInteger getfromcust)
	 {
		 Signature bs = null;
		 byte[]  sigBytes = null;
		 try
	     {			 
			 KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");			 
			 keyGen.initialize(1024, new SecureRandom());
			 KeyPair keypair = keyGen.genKeyPair();
			 SecureRandom random = new SecureRandom();
			 BigInteger b = getfromcust;			
       
			 bs = Signature.getInstance("MD5withRSA");
			 bs.initSign(keypair.getPrivate(), random);
			 String message1 = b.toString();
			 byte[]	bytes = new byte[message1.length()];
			 char[]  chars = message1.toCharArray();
         
			 for (int i = 0; i != chars.length; i++)
			 {
				 bytes[i] = (byte)chars[i];
			 }
			 System.out.print(bytes);
			 bs.update(bytes);         
			 sigBytes =bs.sign(); 
			 			 
			 RSAPublicKey pubKey = (RSAPublicKey)keypair.getPublic();
			 byte[] key = pubKey.getEncoded();
			 FileOutputStream bankkey = new FileOutputStream("bankpk.txt");
			 bankkey.write(key);
			 bankkey.close();
			 
	     }catch(Exception ex) {
	    	 System.out.println("ERROR: ");
	         ex.printStackTrace();
	     }
	     return (sigBytes);
	 }
	 
	 /**
 	 * Updateaccount.
 	 *
 	 * @param account the account
 	 * @param balance the balance
 	 */
 	public static void updateaccount(int account, double balance)
	 {
		 String S_acct = Integer.toString(account);
		 String S_bal = Double.toString(balance);
		 for (int i=0; i <= 1; i++)
		 {
			 if (accountmatrix[i][0].equals(S_acct))
			 {
				 accountmatrix[i][1] = S_bal;				
			 }
		 }		 
	 }	 
	 
	 /**
 	 * Matrixtofile.
 	 */
 	public static void matrixtofile()
	 {		 
	     try 
         {                                       		 
	    	 FileWriter fw = new FileWriter(file.getAbsoluteFile());
			 BufferedWriter writer = new BufferedWriter(fw);
			 
	    	 String part1 = accountmatrix[0][0];
             String part2 = accountmatrix[0][1];
             String part3 = accountmatrix[0][2];
             //String part4 = accountmatrix[0][3];
             
             String content = "";    		 
    		 content = content.concat (part1);
    		 content = content.concat ("-");
    		 content = content.concat (part2);
    		 content = content.concat ("-");
    		 content = content.concat (part3);
    		 //content = content.concat ("-");
    		 //content = content.concat (part4);
    		 
    		 //writer.write(content+"\n");
    		 
    		 String part4 = accountmatrix[1][0];
    		 String part5 = accountmatrix[1][1];
             
             //content = "";    	
    		 content = content.concat ("-");
    		 content = content.concat (part4);
    		 content = content.concat ("-");
    		 content = content.concat (part5);
    		 
    		 writer.write(content);
    		 writer.close();
    		 fw.close();
         } 
	     catch (FileNotFoundException e) 
 		{     
 			System.out.println("Account File not found");
 		} catch (IOException e) 
 		{  
 			System.out.println("Cannot write to Account file");
 		}   		 
	 }	 
	 
	 /**
 	 * Filetomatrix.
 	 */
 	public static void filetomatrix()
	 {
	     BufferedReader reader = null;	    	 
		 try 
         {    
             reader = new BufferedReader(new FileReader(file));           
             String text = null;
                         
            text = reader.readLine();                
            String[] parts = text.split("-");
            String part1 = parts[0]; 
            String part2 = parts[1];  
            String part3 = parts[2];  
            //String part4 = parts[3]; 
            accountmatrix[0][0] = part1;
            accountmatrix[0][1] = part2;
            accountmatrix[0][2] = part3;
            //accountmatrix[0][3] = part4;
            
            //text = reader.readLine();                
            //parts = text.split("-");
            String part4 = parts[3]; 
            String part5 = parts[4];            
            accountmatrix[1][0] = part4;
            accountmatrix[1][1] = part5;  
            reader.close();
         } 
		 catch (FileNotFoundException e) 
 		{     
 			System.out.println("Account File not found");
 		} catch (IOException e) 
 		{  
 			System.out.println("Cannot read Account file");
 		}   		
 		customer_balance = Double.parseDouble(accountmatrix [0][1]);
 	    customer_account = Integer.parseInt(accountmatrix [0][0]);
 	    customer_identity = accountmatrix [0][2];
 	    merchant_balance = Double.parseDouble(accountmatrix [1][1]);
 	    merchant_account = Integer.parseInt(accountmatrix [1][0]);   
	 }	 
    // Variables declaration - do not modify//GEN-BEGIN:variables
    /** The j button2. */
    private javax.swing.JButton jButton2;
    
    /** The j button3. */
    public javax.swing.JButton jButton3;
    
    /** The j panel1. */
    private javax.swing.JPanel jPanel1;
    
    /** The j panel2. */
    private javax.swing.JPanel jPanel2;
    
    /** The j scroll pane1. */
    private javax.swing.JScrollPane jScrollPane1;
    
    /** The j scroll pane2. */
    private javax.swing.JScrollPane jScrollPane2;
    
    /** The j text area1. */
    public static javax.swing.JTextArea jTextArea1;
    
    /** The j text area2. */
    public static javax.swing.JTextArea jTextArea2;
    // End of variables declaration//GEN-END:variables
}

